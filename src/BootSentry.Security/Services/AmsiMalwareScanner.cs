using System.Runtime.InteropServices;
using BootSentry.Core.Enums;
using BootSentry.Core.Interfaces;
using BootSentry.Security.Interop;
using Microsoft.Extensions.Logging;

namespace BootSentry.Security.Services;

/// <summary>
/// Malware scanner implementation using Windows AMSI (Antimalware Scan Interface).
/// </summary>
public sealed class AmsiMalwareScanner : IMalwareScanner, IDisposable
{
    private const string AppName = "BootSentry";
    private const long MaxFileSizeBytes = 250 * 1024 * 1024; // 250 MB (covers Electron apps)

    private readonly ILogger<AmsiMalwareScanner> _logger;
    private readonly IntPtr _amsiContext;
    private readonly object _lock = new();
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the AMSI malware scanner.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <exception cref="InvalidOperationException">Thrown if AMSI initialization fails.</exception>
    public AmsiMalwareScanner(ILogger<AmsiMalwareScanner> logger)
    {
        _logger = logger;

        var hr = AmsiNativeMethods.AmsiInitialize(AppName, out _amsiContext);
        if (hr != AmsiNativeMethods.S_OK)
        {
            _logger.LogError("Failed to initialize AMSI. HRESULT: 0x{HResult:X8}", hr);
            throw new InvalidOperationException($"Failed to initialize AMSI. HRESULT: 0x{hr:X8}");
        }

        _logger.LogDebug("AMSI initialized successfully for {AppName}", AppName);
    }

    /// <inheritdoc />
    public async Task<ScanResult> ScanAsync(string filePath, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (string.IsNullOrWhiteSpace(filePath))
        {
            _logger.LogWarning("ScanAsync called with null or empty file path");
            return ScanResult.Error;
        }

        try
        {
            // Check if file exists
            if (!File.Exists(filePath))
            {
                _logger.LogWarning("File does not exist: {FilePath}", filePath);
                return ScanResult.NotScanned;
            }

            // Check file size
            var fileInfo = new FileInfo(filePath);
            if (fileInfo.Length > MaxFileSizeBytes)
            {
                _logger.LogInformation(
                    "File too large for AMSI scan ({Size:N0} bytes > {MaxSize:N0} bytes): {FilePath}",
                    fileInfo.Length, MaxFileSizeBytes, filePath);
                return ScanResult.TooLarge;
            }

            if (fileInfo.Length == 0)
            {
                _logger.LogDebug("Empty file, skipping scan: {FilePath}", filePath);
                return ScanResult.Clean;
            }

            // Read file content
            byte[] buffer;
            try
            {
                buffer = await File.ReadAllBytesAsync(filePath, cancellationToken);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (IOException ex)
            {
                _logger.LogWarning(ex, "Failed to read file for scanning (file may be locked): {FilePath}", filePath);
                return ScanResult.NotScanned;
            }
            catch (UnauthorizedAccessException ex)
            {
                _logger.LogWarning(ex, "Access denied when reading file for scanning: {FilePath}", filePath);
                return ScanResult.NotScanned;
            }

            cancellationToken.ThrowIfCancellationRequested();

            // Perform AMSI scan
            return ScanBuffer(buffer, filePath);
        }
        catch (OperationCanceledException)
        {
            _logger.LogDebug("Scan cancelled for: {FilePath}", filePath);
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during malware scan: {FilePath}", filePath);
            return ScanResult.Error;
        }
    }

    // HRESULT for ERROR_NOT_READY - no antivirus provider available
    private const int E_NOT_READY = unchecked((int)0x80070015);

    private ScanResult ScanBuffer(byte[] buffer, string contentName)
    {
        lock (_lock)
        {
            if (_disposed)
            {
                return ScanResult.Error;
            }

            var handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            try
            {
                var hr = AmsiNativeMethods.AmsiScanBuffer(
                    _amsiContext,
                    handle.AddrOfPinnedObject(),
                    (uint)buffer.Length,
                    contentName,
                    IntPtr.Zero, // No session for single scan
                    out var amsiResult);

                if (hr != AmsiNativeMethods.S_OK)
                {
                    if (hr == E_NOT_READY)
                    {
                        _logger.LogWarning(
                            "No antivirus provider available for AMSI scan. Enable Windows Defender or install a compatible antivirus. File: {ContentName}",
                            contentName);
                        return ScanResult.NoAntivirusProvider;
                    }

                    _logger.LogWarning(
                        "AMSI scan failed. HRESULT: 0x{HResult:X8}, File: {ContentName}",
                        hr, contentName);
                    return ScanResult.Error;
                }

                _logger.LogDebug(
                    "AMSI scan result: {Result} for {ContentName}",
                    amsiResult, contentName);

                // Interpret result
                if (AmsiNativeMethods.IsMalware(amsiResult))
                {
                    _logger.LogWarning(
                        "Malware detected by AMSI (result: {Result}): {ContentName}",
                        amsiResult, contentName);
                    return ScanResult.Malware;
                }

                if (AmsiNativeMethods.IsBlockedByAdmin(amsiResult))
                {
                    _logger.LogInformation(
                        "Content blocked by admin policy (result: {Result}): {ContentName}",
                        amsiResult, contentName);
                    return ScanResult.Blocked;
                }

                return ScanResult.Clean;
            }
            finally
            {
                handle.Free();
            }
        }
    }

    /// <inheritdoc />
    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        lock (_lock)
        {
            if (_disposed)
            {
                return;
            }

            _disposed = true;

            if (_amsiContext != IntPtr.Zero)
            {
                AmsiNativeMethods.AmsiUninitialize(_amsiContext);
                _logger.LogDebug("AMSI context released");
            }
        }
    }
}
