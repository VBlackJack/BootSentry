using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using Xunit;
using BootSentry.Core.Enums;
using BootSentry.Security.Services;

namespace BootSentry.Security.Tests;

public class AmsiMalwareScannerTests : IDisposable
{
    private readonly Mock<ILogger<AmsiMalwareScanner>> _loggerMock;
    private AmsiMalwareScanner? _scanner;
    private readonly string _testDirectory;

    public AmsiMalwareScannerTests()
    {
        _loggerMock = new Mock<ILogger<AmsiMalwareScanner>>();
        _testDirectory = Path.Combine(Path.GetTempPath(), $"BootSentryAmsiTest_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);

        try
        {
            _scanner = new AmsiMalwareScanner(_loggerMock.Object);
        }
        catch (InvalidOperationException)
        {
            // AMSI not available on this system - tests will be skipped
            _scanner = null;
        }
    }

    public void Dispose()
    {
        _scanner?.Dispose();

        if (Directory.Exists(_testDirectory))
        {
            try
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
            catch
            {
                // Ignore cleanup errors
            }
        }
    }

    private bool IsAmsiAvailable => _scanner != null;

    // ============================================================
    // Basic Functionality Tests
    // ============================================================

    [Fact]
    public async Task ScanAsync_WithNullPath_ReturnsError()
    {
        if (!IsAmsiAvailable)
        {
            return; // Skip if AMSI not available
        }

        var result = await _scanner!.ScanAsync(null!);

        result.Should().Be(ScanResult.Error);
    }

    [Fact]
    public async Task ScanAsync_WithEmptyPath_ReturnsError()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        var result = await _scanner!.ScanAsync("");

        result.Should().Be(ScanResult.Error);
    }

    [Fact]
    public async Task ScanAsync_WithNonExistentFile_ReturnsNotScanned()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        var result = await _scanner!.ScanAsync(@"C:\NonExistent\File\That\Does\Not\Exist.exe");

        result.Should().Be(ScanResult.NotScanned);
    }

    [Fact]
    public async Task ScanAsync_WithEmptyFile_ReturnsClean()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        var emptyFile = Path.Combine(_testDirectory, "empty.txt");
        await File.WriteAllTextAsync(emptyFile, "");

        var result = await _scanner!.ScanAsync(emptyFile);

        result.Should().Be(ScanResult.Clean);
    }

    [Fact]
    public async Task ScanAsync_WithCleanTextFile_ReturnsClean()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        var cleanFile = Path.Combine(_testDirectory, "clean.txt");
        await File.WriteAllTextAsync(cleanFile, "This is a clean text file with no malicious content.");

        var result = await _scanner!.ScanAsync(cleanFile);

        result.Should().Be(ScanResult.Clean);
    }

    [Fact]
    public async Task ScanAsync_WithSystemFile_ReturnsClean()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        // notepad.exe should be a clean system file
        var notepadPath = Path.Combine(Environment.SystemDirectory, "notepad.exe");

        if (!File.Exists(notepadPath))
        {
            return; // Skip if notepad not found
        }

        var result = await _scanner!.ScanAsync(notepadPath);

        result.Should().Be(ScanResult.Clean);
    }

    // ============================================================
    // Cancellation Tests
    // ============================================================

    [Fact]
    public async Task ScanAsync_WithCancelledToken_ThrowsOperationCancelledException()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        var file = Path.Combine(_testDirectory, "test.txt");
        await File.WriteAllTextAsync(file, "test content");

        using var cts = new CancellationTokenSource();
        cts.Cancel();

        var action = async () => await _scanner!.ScanAsync(file, cts.Token);

        await action.Should().ThrowAsync<OperationCanceledException>();
    }

    // ============================================================
    // Dispose Tests
    // ============================================================

    [Fact]
    public async Task ScanAsync_AfterDispose_ThrowsObjectDisposedException()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        var file = Path.Combine(_testDirectory, "test.txt");
        await File.WriteAllTextAsync(file, "test content");

        _scanner!.Dispose();

        var action = async () => await _scanner.ScanAsync(file);

        await action.Should().ThrowAsync<ObjectDisposedException>();
    }

    [Fact]
    public void Dispose_MultipleTimes_DoesNotThrow()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        var action = () =>
        {
            _scanner!.Dispose();
            _scanner.Dispose();
            _scanner.Dispose();
        };

        action.Should().NotThrow();
    }

    // ============================================================
    // EICAR Test (Standard Antivirus Test File)
    // ============================================================

    [Fact]
    public async Task ScanAsync_WithEicarTestFile_ReturnsMalware()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        // EICAR test string - standard antivirus test pattern
        // This is NOT actual malware, but antivirus software is designed to detect it
        var eicarString = @"X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*";
        var testFile = Path.Combine(_testDirectory, "eicar.com");

        try
        {
            await File.WriteAllTextAsync(testFile, eicarString);
        }
        catch (IOException)
        {
            // Windows Defender might block the file creation
            return;
        }

        if (!File.Exists(testFile))
        {
            return; // File was blocked by antivirus
        }

        var result = await _scanner!.ScanAsync(testFile);

        // Most antivirus solutions will detect EICAR as malware
        result.Should().BeOneOf(ScanResult.Malware, ScanResult.Blocked, ScanResult.NotScanned);
    }

    // ============================================================
    // Large File Tests
    // ============================================================

    [Fact]
    public async Task ScanAsync_WithLargeFile_HandlesGracefully()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        // Create a file larger than the 100MB limit
        var largeFile = Path.Combine(_testDirectory, "large.bin");

        // Create a sparse file of 101 MB (don't actually write all the data)
        using (var fs = new FileStream(largeFile, FileMode.Create))
        {
            fs.SetLength(101 * 1024 * 1024); // 101 MB
        }

        var result = await _scanner!.ScanAsync(largeFile);

        result.Should().Be(ScanResult.NotScanned);
    }

    // ============================================================
    // Concurrent Scan Tests
    // ============================================================

    [Fact]
    public async Task ScanAsync_ConcurrentScans_AllComplete()
    {
        if (!IsAmsiAvailable)
        {
            return;
        }

        // Create multiple test files
        var files = new List<string>();
        for (int i = 0; i < 5; i++)
        {
            var file = Path.Combine(_testDirectory, $"concurrent_{i}.txt");
            await File.WriteAllTextAsync(file, $"Test content {i}");
            files.Add(file);
        }

        // Scan all files concurrently
        var tasks = files.Select(f => _scanner!.ScanAsync(f)).ToList();
        var results = await Task.WhenAll(tasks);

        results.Should().OnlyContain(r => r == ScanResult.Clean || r == ScanResult.NotScanned);
    }
}
